# 软件工程
## 第一章 软件工程概述
###  软件的概念
> 软件 = 程序 + 数据 + 文档
### 软件的特点
> **软件是设计开发的，不是制造的，充满个人行为和个人因素**
> 软件是软件团队的工作
> 软件是定制的
> 软件是生产制造的
### 软件危机和现状
> **软件危机** 
> 在软件的开发和维护过程中所遇到的一系列严重的问题
> **软件危机的原因**
> - **软件本身的原因**
> --软件是逻辑部件，缺乏可见性
> --维护困难
> --软件越来越庞大和复杂，需要分工协作
> - **开发和维护方法不正确**
> --需求分析不充分或存在错误
> -- 开发过程不规范，错误认为：软件开发=编程序
> --不注重文档工作，软件难以维护
> --缺少软件评测手段
> **现状**
> - 大大改善，但没有摆脱软件危机的困扰
> - 软件本身特点
> - 开发和维护方法问题
> - 对软件的需求远远超出现有的生产能力
> - 构造安全可靠软件的技术能力不足
### 软件工程的定义和发展过程
> **软件工程的定义**
> （1）应用系统的、规范的、可度量的方法，来开发、运行和维护软件，即把工程应用到软件。
> （2）对（1）中各种方法的研究。
> **发展过程**
>   **第一代软件工程——传统软件工程（结构化方法学）**
>   --  为克服软件危机提出
>   --  将软件开发纳入工程化轨道，基本形成软件工程的概念、框架、技术和方法。
>   **第二代软件工程——对象工程（面向对象方法学）**
>   --  面向对象的方法与技术得到发展，研究的重点转移到面向对象的分析与设计，演化为一种完整的软件开发方法和系统的技术体系。
>   **第三代软件工程——过程工程**
>   --  提高软件生产率、保证软件质量的关键是“软件工程”，是软件开发和维护中的管理和支持能力，逐步形成软件过程工程。
>   **第四代软件工程——构件工程**
>   基于构件的开发方法取得重要进展，软件系统的开发可通过使用现成的可复用的构件组装完成，而无需从头开始构件，以此达到提高效率和质量，降低成本的目的。
## 第二章 过程模型
### 软件的生命周期、软件过程定义
> **软件的生命周期**
> 软件产品或软件系统从设计、投入使用到被淘汰的全过程。
>  **软件过程定义**
>  在工作产品构建过程中，所需完成的工作活动、动作和任务的集合
### 常见的模型——传统模型
#### 瀑布模型
> - **优点**
> --  每个阶段都有与其相关联的里程碑和可交付的产品
> --  每个阶段结束前完成文档审查，及早改正错误
> --  阶段间具有顺序性和依赖性
> - **缺点**
> -- 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量
>  -- 用户只有等到整个过程的末期才能看见开发成果，从而增加了开发的风险
> -- 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果
> -- 无法适应需求不明确和需求的变化
> -- 不能反应实际的开发方式，软件开发需要迭代
> - **应用场合** 
> 系统需求明确且稳定、技术成熟、工程管理较严格的场合，如军工、航天、医疗。
####  V模型：瀑布模型的变种
####  原型模型
> - **优点**
> --  减少需求不明确带来的风险
> - **缺点**
> --  构造原型采用的技术和工具不一定主流
> --  快速建立起来的系统加上连续的修改可能导致原型的质量低下
> --  设计者在质量和原型中进行折中
> --  客户意识不到一些质量问题
> - **应用场合**
> 客户定义一个总体目标，但是他们并不清楚系统的具体输入输出；或开发者不确定算法的效率、软件与操作系统是否兼容以及客户与计算机交互的方式。
#### 增量模型
> - **优点**
> --  不需要提供完整的需求，只要有一个增量出现，开发就可以进行
> --  在项目的初始阶段不需要投入太多的人力资源
> --  产品逐步交付，软件开发能够较好的适应需求的变化
> --  能够看到软件中间产品，提出改进意见，减少返工，减少开发风险
> --  软件能够更早投入市场
> --  开放式体系结构，便于维护
> - **缺点**
> --  每个增量必须提供一些系统功能，这使得开发者很难根据客户需求给出大小合适的增量
> --  软件必须具备开放式体系结构
> -- 已退化成边做边改的方式，使软件工程控制失去整体性
> - **适用场合**
> 软件开发中需求可能发生变化、具有较大风险、或者希望尽早进入市场的项目
#### 螺旋模型
> - **优点**
> --  强调原型的可扩充性和可修改性，原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力，支持用户需求的动态变化
> --  原型可看作可执行的需求规格说明，易于为用户和开发人员共同理解，还可作为继续开发的基础，并为用户参与所有关键决策提供了方便
> --  为项目管理人员及时调整管理决策提供了方便，进而可降低开发风险。
> - **缺点**
> --  如果每次迭代的效率不高，致使迭代次数过多，将会增加成本并推迟提交时间
> --  使用该模型需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高，否则会带来更大风险
> - **适用场合**
> 需求不明确或者需求可能发生改变的大型复杂的软件系统。支持面向过程、面向对象等多种软件开发方法，是一种具有广阔前景的模型
##### 协同模型
> - **适用场合**
> 不同团队共同开发的项目
####  喷泉模型
> - **适用场合**
> 面对对象开发
### 常见模型——现代模型
**基于构件的开发模型
快速应用开发模型
形式话方法模型
面向方面的软件开发
Rational统一过程
敏捷软件开发**
### CMMI能力成熟度模型
>1.初始级（有能力的人和个人英雄主义）
>2.可重复级（基本项目管理）
>3.已定义级（过程标准化）
>4.量化管理级（量化管理）
>5.优化级（持续的过程改进）
## 第三章 需求分析
### 需求分析的概念和过程
> **概念**
>确定系统必须具有的功能和性能，系统要求的运行环境，并且预测系统发展的前景。
>**过程**
> - 需求确认
>1.需求获取
>2.需求提炼
>3.需求描述
>4.需求验证
> - 需求变更
### 面向过程结构化分析方法（数据流图）
#### 注意的问题
> - 不要把控制流作为数据流
> - 不要标出激发条件
> - 每个加工至少有一个输入数据流和一个输出数据流
> - 数据流必须要么从某个加工流出、要么流入某个加工，而不能直接从外部项流向数据存储等 
### 面向对象的分析方法（用例图）
#### 注意的问题
> - 把用例当成是单独的步骤、操作或事物的处理
> - 把执行者动作当作例
> - 把系统活动当成用例
#### 关系
>**参与者和用例之间的关系**
> -- 如果使用带箭头的线段，箭头表示在这一关系中哪一方是对话的主动发起者，箭头所指方是对话的被动接受者
> -- 如果不想强调对话中的主动和被动关系，可以使用不带箭头的线段
>**参与者之间的关系**
> -- 用空心箭头表示继承关系
>**用例之间的关系**
> -- **包含（Include）**
> 一个用例可以包含其他用例具有的行为，并把它所包含的用例行为作为自身行为的一部分
> -- **扩展（Extend）**
> 可选的只在特定情况下执行的行为，扩展关系常常来处理异常
> -- **泛化（Generalization）**
> 父用例可以被特化形成多个子用例，父用例和子用例的关系就是泛化关系
### 功能性需求和非功能性需求
>**功能性需求**
>描述系统应该做什么，即为用户和其他系统完成的功能、提供的服务。
>**非功能性需求**
>必须遵循的标准，外部界面的细节，实现的约束条件，质量属性等等。非功能需求限定了选择解决方案的范围，如运行的平台、实现技术、编程语言和工具等。
## 系统设计
### 软件设计过程、软件设计的概念和原则
#### 软件设计过程
>总体设计、详细设计
#### 软件设计的概念和原则
> 1.抽象
> 2.体系结构
> 3.模式
> 4.模块化
> 5.信息隐藏
> 6.功能独立
> 7.精化
> 8.重构
### 传统的软件设计方法（程序流程图）
#### 程序流程图的基本结构
> - 顺序结构（Sequence）
> - 选择结构（Selection）
>--  二元选择结构（基本结构）
>-- 多重选择结构
> - 循环结构（Iteration）
>-- while-do结构
>--do-until结构
### 面对对象的系统设计方法（顺序图）
## 程序实现
## 软件质量保证
### 质量保证相关概念
#### 软件质量
>明确表示是否符合功能和性能要求，明确地记载开发标准和所有专业开发软件的期望的隐性特点。
>1.与需求一致
>2.与隐含需求一致
>3.与指定的开发标准一致
#### 软件质量保证（SQA）
>一个监控的软件工程以确保软件质量的过程
#### 软件质量保证涵盖了整个软件开发过程
### 软件测试的目标
> - 确认系统满足其预期的使用和用户的需要
> - 确认解决了所需解决的问题
> - 便于及早发现软件和系统的异常
> - 及早提供软件和系统的性能评估
> - 为管理提供真实信息，以决定在当前状态下发布产品在商业上的风险
> - 鉴别出程序在功能等方面的异常集聚之处
### 软件测试的策略（V模型）
> -- **单元测试**
> 验证软件模块是否按照详细设计说明正确运行
> -- **集成测试**
> 检查多个模块之间是否按概要设计说明的方式协同工作
> -- **系统测试**
> 验证整个系统是否满足需求规格说明
> -- **验收测试**
> 从客户的角度检查系统是否满足合同中定义的需求，以及以确认产品是否能复合业务上的需求
#### 白盒测试（结构性测试）的逻辑覆盖
> - **语句覆盖**
> 每条语句至少执行一次
> 问题：只覆盖一条路径
> - **判定覆盖/分支覆盖**
> 每个判定的取真分支和取假分支至少执行一次
> 问题
> - **条件覆盖**
> 每个判定的每个条件都能取到可能的结果
> 问题：只行了一个路径
> - **判定条件覆盖**
> 不仅每个判定的取真分支和取假分支至少执行一次，而且每个判定的每个条件都能渠道可能的结果
> - **条件组合覆盖**
> 每个判定表达式中条件的各种可能组合都至少出现一次
> 问题：不能覆盖全部路径
> - **路径覆盖**
>程序中每条可能路径都至少执行一次
> - **控制流图覆盖**
> -- 控制流图覆盖测试是将代码转变为控制流图（CFG），基于其进行测试的技术
> -- 控制流图覆盖属于白盒测试
> 1.节点覆盖
> 2.边覆盖
> 3.路径覆盖
> **控制流图**
> 1.退化的程序流程图，仅描述程序内部的控制流程
> 2.将程序流程图中的每个处理符号都退化成一个结点
> 3.分支的汇聚处应该有一个汇结点
> 4.如果判断中的条件表达式是复合表达式，则改为嵌套的简单条件表达式
> 5.将程序流程图中连接处理符号的流线变成连接结点的有向弧
#### 白盒测试技术——循环测试
>1.跳过整个循环
>2.一次通过循环
>3.两次通过循环
>4.m次通过循环，其中m < n
>5.（n-1），n，和（n+1）次通过循环
>（其中n是允许通过的最大次数）
#### 黑盒测试技术（功能测试）
> - **等价类划分**
> -- 完全不考虑程序的内部结构，只依据程序的规格说明来测试用例。
> -- 把所有可能的输入数据（将程序的输入域划分为若干部分,然后从每一部分选取少数有代表性的数据作为测试用例）
> -- 把输入域划分成若干等价类，据此导出测试用例
> -- 等价类：输入域的子集，该子集合中，各个输入数据对于揭露程序中的错误是等效的
> -- 有效等价类和无效等价类
> **等价类划分方法的测试步骤**
> 1.根据输入条件确立等价类，列出所有划分出的等价类
> 2.为每一个等价类规定一个唯一编号
> 3.设计一个测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类，重复这一步，直到所有地有效等价类都被覆盖
> 4.设计一个测试用例，使其仅覆盖一个尚未被覆盖地无效等价雷，重复这一步，知道所有的无效等价类都被覆盖
> - **边界值分析**
> 1.若输入条件指定以a和b为边界的范围，则测试用例应该包括：a、b，略大于a、略小于a、略大于b、略小于b
> 2.若输入条件指定为一组值，则测试用例应该包括其中的：最大值、最小值、略大于最大值、略小于最大值、略大于最大值、略大于最小值
> 3.若内部数据结构有预定义的边界值，则在边界处设计测试用例
> 4.在等价类的边界选择测试用例
## 软件维护
### 软件维护的定义和分类
> **软件维护的定义**
>在软件运行阶段对软件产品所做的修改
>**基本类型**
>-- **纠错性维护**
>因开发时测试的不彻底、不完全，必然会有部分隐藏的错误遗留到运行阶段
>-- **适应性维护**
>环境改变引起的错误(外部环境、数据环境)
>-- **完善性维护**
>用户对软件提出新的功能与性能要求
>-- **预防性维护**
>采用先进的软件工程方法对需要维护的软件或软件中的一部分（重新）进行设计、编码和测试
### 软件可维护性的典型特征
>1.可理解性
>2.可测试性
>3.可修改性
>4.可移植性
>5.可重用性
### 维护费用估算
>参考模型：M = P + K * exp（c - d）
>>- M是维护用的总工作量
>>- P是生产性工作量
>>- K是经验常数
>>- c是复杂程度，d是维护人员对软件的熟悉程度
### 软件维护过程模型（IEEE维护模型图）
### 软件维护技术
>- **程序理解**
>建立从问题（应用）域到程序设计（实现）域的映射清晰
>- **软件再工程**
>对现有软件进行仔细审查和改造，对其进行重新构造，使之成为一个新的形式，同时包括随之产生的对新形式的实现
>- **软件逆向工程**
>是分析目标系统，识别系统的构件及其交互关系，并且通过高层抽象或其他形式来展现目标系统的过程
>**逆向工程的主要内容**
>1.数据的逆向工程
>内部数据结构的逆向工程、数据库结构的逆向工程
>2.处理的逆向工程
>-- 需要在不同的抽象级别（系统级、程序级、构件级、模式级和语句级）分析代码
>--对大型系统，通常用半自动方法完成逆向工程
>3.用户界面的逆向工程
>--界面必须处理的基本动作是什么？
>--系统对这些动作的行为反应的简要描述是什么？
## 项目管理
### 软件项目管理相关概念
>**定义**
>计划、协调、度量、监控、控制及报告等管理方法在软件开发和维护中的具体应用，以保证整个过程是系统的、有原则的、可量化的。
>**目标**
>--软件产品达到预期的功能和性能要求（质量）
>--项目在合同期限内完成和交付（进度）
>--项目开销控制在预算之内（成本）
>**基本要素**
>--人员管理
>--产品管理
>--过程管理
>--项目管理 
### 软件度量
>**定义**
>一种量化衡量方法，使得人们可以理解和把握软件项目的（生产）效率（或者所需要的劳动量）
>- 软件规模：软件产品的大小
>--直接测量：以代码行表示，以千行代码为单位(KLOC)
>--间接测量：以功能点表示，以功能点为单位（FP）
>- 工作量：投入的人力
>--是软件规模的函数，以人月为单位（PM）
>- 生产率：
>--直接测量/基于规模（KLOC）：如在一个特定时间内产生的代码行数
>--及娜姐测量/基于功能点（FP）：如在一个给定的时间内生产出的功能点和目标点
>- 进度：预计的开发时间，以月为单位（M）
>**规模估算——代码行技术**
>1.将软件分解为尽量小且可独立估算的子功能
>2.计算每个子功能的代码行数
>>最小代码行数估算值：a
>>最可能的代码行数估算值：m
>>最大代码行数的估算值：b
>>代码行数期望值：**L=（a+4m+b）/6**
>3.将所有子功能的代码行数期望值相加得到系统的代码行数
>4.由多名有经验的开发人员分别给出估算，然后得出估算的平均值
>**规模估算——功能点技术**
### 项目进度计划
>** 两种方式**
>1.系统最终交付日期已确定，软件开发部门必须在规定期限内完成；
>2.系统最终交付日期之确定了大致的年限，最终交付日期由软件开发部门确定。
>**进度计划落空，会导致市场机会的丧失，使用户不满意，而且也会导致成本的增加**
>**在考虑进度计划时，要把工作量与花费时间联系起来，合
理分配工作量, 利用进度计划的有效分析方法严密监控软
件开发的进展情况，使软件开发进度不致拖延。**